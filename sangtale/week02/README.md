# Week02

# To Do

- 2주차: 2부 C# 프로그래밍 시작하기 (126p - 217p)
    - 4장 C# 프로그래밍 시작하기
    - 5장 게임 오브젝트 제어하기
    - 과제
        - 4장, 5장의 예제 스크립트를 작성하고 github에 pull request로 제출
        - 4장 내용 중 자신이 기존에 배웠던 언어와 차이점이 뭔지 찾아서 정리하기
            - C#이 처음인 사람은 C# 언어에 대한 첫인상
        - 객체 지향에 대한 이해도 정리


# 4장 | C# 프로그래밍 시작하기

예전에 C#을 배우기 시작했을 때 팔만코딩경에 썼던 글들이 있다. (<이것이 C#이다> 도서를 참조하여 공부했다)<br/>
나처럼 피신을 통해 프로그래밍이 처음인 사람에게 도움이 됐으면 좋겠다는 심정으로 썼다.<br/>

# Mac과 VS Code로 C#을 할 수 없을까? (feat. C# 찍먹)
https://80000coding.notion.site/Mac-VS-Code-C-feat-C-bd91b45ccbc6433498c7935c1881fb25

# Windows와 Visual Studio로 C# 시작하기
https://80000coding.notion.site/Windows-Visual-Studio-C-78908a07c2674680a2b69ded5ae545a8

# C# 입문 1. 자료형, 문자열 가지고 놀기
https://80000coding.notion.site/C-1-776e0dbe06c549a88298afcd213bc5dd

# C# 입문 2. 메소드(함수), 클래스와 객체
https://80000coding.notion.site/C-2-1c8593a4d0e546988ba5431adacfe60a

* [간략한 C와 C#의 차이점]

1. 헤더와 헤더 파일이 없습니다.
2. C#은 C와 다르게 문자열(String)이라는 자료형이 있습니다. (Farewell To Arrays!)
3. char 자료형이 2바이트입니다. (아스키코드 문자가 아니고 유니코드 문자)
4. boolean 자료형이 내장돼 있습니다. 이를 제외한 자료형으로 조건문에서 논리연산을 할 수 없습니다.
5. foreach문이 있습니다.
6. 모든 자료형은 Null이 될 수 없습니다. Nullable를 제외하곤 말이죠...
7. 킹갓 자료형 var가 있습니다. 컴파일 타임에 컴파일러가 자료형을 맞춰줍니다.
> 그렇지만 킹갓 자료형 var에도 한계가 있는데, 'var'는 지역 변수 선언이나 스크립트 코드에만 표시할 수 있습니다. (킹갓도 자신의 필드와 스코프에서만 킹갓일뿐...)


# 5장 | 게임 오브젝트 이해하기

본격적인 클래스와 객체 지향 프로그래밍에 대해 설명하는 장이다.<br/>
* 프로젝트를 시작하기 전의 반성
얼마 전, cpp module 평가를 갔을 때 코드 리뷰 중에 피평가자에게 '객체 지향 프로그래밍이 뭐고, 필요성이 뭔가? 절차지향으로도 할 수 있지 않나?'라는 질문을 역으로 받은 적이 있다. 그때 머리로 망치를 맞은 충격을 느낀 적이 있다. 나는 대체 뭘 배운 것일까? <br/>
그렇게 나를 돌아봤다. 절차지향 프로그래밍으로 프로그래밍을 프로그래밍을 처음 배웠고, unity를 하기 위해 객체 지향 프로그래밍을 배우긴 했던 나이기에, 객체 지향 프로그래밍에 대한 필요성을 느꼈기 보다는, '그냥 C#이 객체 지향 프로그래밍이라서 배웠기 때문에' 아직 진정성 있게 절차지향 프로그래밍의 필요성과 결핍성이 없었다. 그로 인해 '절차지향 프로그래밍'과 '객체 지향 프로그래밍'을 이해하고 '구분 짓기'가 필요했다. <br/>

* 객체 지향 패러다임
패러다임의 발전 과정을 보면 점점 개발자들이 편하게 개발할 수 있도록 개선되는 방식으로 나아가고 있는 걸 확인할 수 있다.<br/>
가장 먼저 순차적, 비구조적 프로그래밍이 있다. 말 그대로 순차적으로 코딩해나가는 것이다. <br/>
필요한 게 있으면 계속 순서대로 추가해가며 구현하는 방식이다. 직관적일 것처럼 생각되지만, 점점 규모가 커지게 되면 어떻게 될까? <br/>
이런 비구조적 프로그래밍에서는 goto문을 활용한다. 만약 이전에 작성했던 코드가 다시 필요하면 그곳으로 이동한다. 점점 규모가 커지면서 goto문을 무분별하게 사용하게 되고, 코드의 흐름은 이리 뛰고 저리 뛰고 방아깨비 널뛰기 하듯이 난잡해진다. <br/>
<br/>
최단거리를 구하는 '다익스트라 알고리즘으'로 우리에게 익숙한 에츠허르 다익스트라는 1968년 <GOTO문의 해로움>이라는 논문에서 이를 지적하고, '구조적 프로그래밍'을 제안했다.<br/>

* goto문의 대표적인 단점 3가지
1. 무조건 분기를 지시하는 저급의 제어 구조이므로 do while문 이나 case문 등과 같은 블록의 개념을 갖지 못한다. <br/>
2. 프로그램의 흐름을 복잡하게 만들어, 작성된 프로그램의 제어 구조를 이해하기가 어렵다. <br/>
3. 프로그램의 구조를 불분명하게 만든다. <br/>
4. 실행의 흐름을 파악하는 것이 코드 읽는 순서랑 다르기 때문에 검증, 수정이 어렵다. <br/>

* 구조적 프로그래밍
1. 프로그램의 흐름이 복잡하지 않아야 한다.<br/>
2. 큰 문제(프로그램의 목표)를 해결하기 위해 함수를 세분화하여 분업한다. 탑 다운(Top-down)방식이라고 한다.<br/>
3. 단일 입·출구(single entry, single exit)를 가져야 한다.<br/>
4. 가능한 goto문을 사용하지 말자.<br/>
5. 순차, 선택, 반복 논리의 세가지 논리 구조로 구성한다.<br/>
- 순차구조(sequence) : 하나의 일이 수행된 후, 다음 일이 순서적으로 수행된다. (구문 순서에 따라)<br/>
- 선택구조(selction) : 프로그램의 상태에 따라서 여러 구문들 중에서 하나를 수행하는 것이다. 주로 if, then, else, endif, switch, case와 같은 키워드로 표현한다.<br/>
- 반복(repetition) : 프로그램이 특정 상태에 도달할 때까지 구문을 반복하여 수행하거나, 집합체의 각각의 원소들에 대해 어떤 구문을 반복 수행하는 것이다. 보통 while, repeat, for, do-until 같은 키워드로 표현한다.<br/>
6. 반복될 가능성이 있으면, 함수(프로시저)로 만들어 사용해라.<br/>
> 프로시저(procedure)?<br/>
반환값(return value)이 따로 존재하지 않는 함수를 뜻한다. 예를 들면, printf와 같은 함수는 반환값을 얻기 위한 것보단, 화면에 출력하는 용도로 쓰이는 함수지만 목적 자체는 프로시저에 가깝다고 할 수 있다.<br/>

* 구조적 프로그래밍의 한계와 객체 지향 프로그래밍의 탄생 <br/>
구조적 프로그래밍으로 도서 관리 프로그래밍을 만든다고 가정해보자. 그렇다면 구조가 이렇게 될 것이다. <br/>
1. 어떤 도서가 <도서 등록> 함수에 들어가서 제목과 저자, 번호, 출판사 등의 정보를 입력받고 등록이 된다. <br/>
2. 어떤 대출자가 어떤 도서를 대출하려고 하면 먼저 그 대출자가 <회원 등록>을 하는 함수에 들어가야 한다. <br/>
3. 2의 과정을 대출자가 도서를 대출하려면 <도서 대출>이라는 함수에 도서 대출자와 도서 구조체를 인자로 넣어야 할 것이다. 만약 도서가 이미 대출이 됐다면, <도서 대출> 함수는 이미 대여됐다고 알려야 할 것이다. <br/>
4. 3의 과정에서 도서 대출을 완료했다면 도서 정보에 대출자를, 혹은 회원 정보에 대출한 도서를 입력한다.<br/>
> 여기서 구조적 프로그래밍의 한계가 등장한다. '도서를 대출했다'는 데이터를 누가 다룰 것이고, 어떻게 다룰 것인가에 대해 모호하다.<br/>
5. 이하 생략(...)<br/>

- 이를 객체 지향 프로그래밍으로 해결한다면?
* 도서라는 객체
도서명, 저자, 출판사, 도서번호, (...), 스스로를 회원이라는 객체에 대출하는 함수, 스스로를 반납하는 함수, 대여 여부 등 <br/>
* 대출자라는 객체
이름, 생년월일, 가입 연도, (...) 대여 정보, 도서 예약하는 함수, 연체했을 시에 대여를 금지하는 함수 등 <br/>

위의 구조적 프로그래밍의 순차적인 구조를 보는 것보다 객체를 들여다 보는 것만으로 코드의 흐름을 한 눈에 파악할 수 있다. <br/>
<br/>

* 객체 지향 프로그래밍의 특징

1. 추상화(abstraction)
<img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/376197d7-95f3-4c0b-878b-b9d4710bcab6/GAhMIfG.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220726%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220726T044128Z&X-Amz-Expires=86400&X-Amz-Signature=3e865dca898bf0fa3cf74a7f9634bbdde595798ae7e40a8945ca32abdddd29a4&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22GAhMIfG.png%22&x-id=GetObject"><br/>

> 필요로 하는 속성이나 행동을 추출하는 작업.
여기서 추상화된 정보는 클래스이고, 이 클래스가 특별해 지는 순간, 즉 메모리에 올라가는 순간 실체(instance)라고 한다.<br/>
위로 예를 들면 도서는 클래스이고, <레트로의 유니티 게임 프로그래밍 에센스>는 인스턴스이다. <br/>
객체지향 프로그래밍에서 코드 재사용에 가장 가까운 개념일 것이다.<br/>
김춘수의 <꽃>이 생각나는 부분이다. 어떤 특별한 이름을 부여받기 전에는 하나의 클래스에 밖에 지나지 않았고, 이름을 불러주자(namespace) 그제야 인스턴스가 됐다. <br/>

2. 캡슐화(encapsulation)
> 낮은 결합도를 유지할 수 있도록 설계하는 것.
한 곳에서 데이터에 변화가 일어나도 다른 곳에 미치는 영향을 최소화 하는 것을 말한다. <br/>
절차 지향 프로그래밍, 그리고 구조적 프로그래밍의 가지는 문제점이 바로 어떤 함수에 잘못된 데이터가 들어가서 데이터가 오염되는 것이다. <br/>
이를 위해 코드의 결합도(coupling)를 낮게 만들고, 캡슐화와 정보 은닉성이 객체 지향 프로그래밍의 주안점이 됐다.
> 결합도 : 어떤 기능을 실행할 때 다른 클래스나 모듈에 얼마나 의존적인가를 나타내는 말이다. 즉, 독립적으로 만들어진 객체들 간의 의존도가 최대한 낮게 만드는 것이 중요하다. 객체들 간의 의존도가 높아지면 굳이 객체 지향으로 설계하는 의미가 없어진다. <br/>
우리는 소프트웨어 공학에서 객체 안의 모듈 간의 요소가 밀접한 관련이 있는 것으로 구성하여 응집도를 높이고 결합도를 줄여야 요구사항 변경에 대처하는 좋은 설계 방법이라고 배운다. 이것이 바로 캡슐화와 크게 연관된 부분이라고 할 수 있다. 그렇다면, 캡슐화는 어떻게 높은 응집도와 낮은 결합도를 갖게 할까?<br/>
바로 정보 은닉을 활용한다. 외부에서 접근할 필요가 없는 것들은 private으로 접근하지 못하도록 제한을 두는 것이다. 위의 도서 프로그램으로 예를 들자면 도서가 스스로를 반납하는 함수를 private으로 둠으로, 대출자 클래스가 스스로를 반납하는 함수에 들어가는 경우를 방지할 수 있다. <br/>
실제로 public과 static으로 점철된 코드라면 자동완성 기능에서 필요 없는 메소드를 마구잡이로 추천해 줄 것이다.<br/>

3. 상속(inheritance)
> 일반화 관계(Generalization)라고도 하며, 여러 개체들이 지닌 공통된 특성을 부각시켜 하나의 개념이나 법칙으로 성립하는 과정
일반화(상속)은 또 다른 캡슐화다. 부모 클래스로부터 상속 받은 자식 클래스는 외부로부터 은닉되기 때문이다. (도서를 상속 받은 클래스는, 대출자로부터 은닉된다.)

* 상속 재사용의 단점
1. 상위 클래스(부모 클래스)의 변경이 어려워진다.
> 부모 클래스에 의존하는 자식 클래스가 많을 때, 부모 클래스의 변경이 필요하다면 이를 의존하는 자식 클래스들이 영향을 받게 된다.
2. 불필요한 클래스가 증가할 수 있다.
> 유사기능 확장시, 필요 이상의 불필요한 클래스를 만들어야 하는 상황이 발생할 수 있다.
3. 상속이 잘못 사용될 수 있다.
> 같은 종류가 아닌 다른 클래스의 구현을 재사용하기 위해 상속을 받게 되면, 문제가 발생할 수 있다. 이런 문제는 전 주에서 짚고 넢어갔는데, 컴포넌트 패턴 혹은 컴포지션으로 해결할 수 있다. 상속 받는 클래스가 부모 클래스와 IS-A(is a relationship) 관계가 아닌, HAS-A 관계(has a relationship)일 때 이에 해당한다. 즉 상속이 코드 재사용만을 위해서 사용되는 일은 없어야 한다.


# 간략한 Week02 회고
여러 가지 얄팍하게 알고 있던 것들에 대해서 조금 명확하게 짚고 넘어갔다. <br/>
또한 큐브 오브젝트에 Rigidbody 컴포넌트를 주어 점프를 시켜봤다. 바닥을 깔지 않으니 끝없이 떨어지는 큐브... 🥲 <br/>
다음 장부터 본격적인 게임 제작에 들어갈 듯하다. 파이팅! <br/>
