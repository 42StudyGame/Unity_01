# Week03

# 게임 파일
https://drive.google.com/file/d/17WnD9F1kLPoDXK3d5LYXLaPlxN2FBCZj/view?usp=sharing

# 플레이 영상
https://youtu.be/iIL87222swM

# To Do

- 3주차: 3부 닷지 플레이어 제작 (220p - 359p)
    - 6장 닷지: 플레이어 제작
    - 7장 닷지: 탄알 제작
    - 8장: 닷지: 게임 매니저와 UI, 최종 완성
    - 과제
        - 3부 닷지 게임의 제작 예제 프로젝트를 github에 올리고 플레이 영상도 올려보기
        - 만약 xbox controller나 다른 컨트롤러가 있는 분은 연결해서 해보세요 재밌습니다!


# 6~8장 | 닷지 (플레이어 제작, 탄알 제작, UI 제작)

본격적인 게임 개발! 예제 프로그램을 다운 받아 구동해 봤다. <br/>
탄막을 피해 원통을 움직여서 오래 살아남는 게임이다. <br/>
simple is best, 간단하지만 재미난 구성이다. <br/>

* **Dodge에서 해보고 배운 것**
    
    1. Inspector의 Transform으로 컴포넌트의 스케일과 위치를 수정하기
        - Plane의 크기와 유닛 단위
            유니티에서 1 유닛은 Cube 한 변의 길이다. 1 유닛을 현실의 몇 미터에 대응할지는 개발자 마음이지만, 편의상 1유닛을 1미터로 취급한다.<br/>
    
    2. 머티리얼(Material)
        - 머티리얼은 Shader와 Texture가 합쳐진 에셋으로, 오브젝트의 픽셀 컬러를 결정한다.
        - 알베도(Albedo)는 반사율이라는 뜻으로, 물체가 어떤 색을 반사할지 결정합니다. 알베도의 RGB 값을 수정해서 물체의 기본색을 결정한다.
    
    3. 여러 가지 오브젝트 만들고, 카메라 설정하기
        - 바닥과 벽, 그리고 원통 모양의 플레이어를 만들고, 머티리얼을 입혀 색깔을 지정한다.
        - 빈 오브젝트를 만들고 여러 오브젝트를 담을 부모 프로젝트로 지정한하여 복잡해진 하이어라키창을 정리한다.
        - 카메라 위치를 설정하고 디폴트 설정인 스카이 박스(Skybox)를 단색(Solid Color)으로 바꾼다.
        - 캡슐 오브젝트를 만들어 플레이어로 지정하고 푸른색의 머티리얼을 입힌다.
        - 화면을 회전시키는 Rotate 스크립트를 만들어 화면을 회전해봤다. transform.Rotate()메소드에 Time.deltaTime을 곱하지 않고 그냥 줬을 시에 엄청 빠르게 회전하는 것도 확인했다.
        
    4. 오브젝트 설정하기
        - 이후에 탄알과 플레이어가 충돌했는지 확인하기 위해 플레이어 오브젝트에 태그(Tag)를 자기 자신으로 추가한다.
            > 이렇게 태그를 설정하면 나중에 탄알이 플레이어와 충돌했을 때만 게임오버를 실행할 수 있다. 
        - 플레이어에 Rigidbody 컴포넌트를 추가하여 물리적인 효과를 준다.
            > Rigidbody의 제약(Constraints)을 추가로 설정한다. y축 Position을 고정하지 않으면 벽을 뛰어 넘어서고, x, z축 Rotation을 고정하지 않으면 오뚝이처럼 뒤뚱거린다. (play 버튼을 누른 후 체크를 해제하면 바로 확인이 가능하다)
        - 키 입력을 받아 움직이는 c# 스크립트를 작성하고, 플레이어 오브젝트의 컴포넌트에 추가한다.
        - 오브젝트의 collider 컴포넌트의 Is Trigger 옵션에 대해 이해했다. 이 trigger를 통하여 다른 오브젝트와 상호작용하고 서로 메시지를 주고 받을 수 있다. 만약 플레이어 오브젝트에 Is Trigger를 체크하고 충돌 시 별다른 명령을 입력하지 않을 시에 벽을 통과하는 것을 확인할 수 있다.
        - 자주 사용하는 오브젝트는 하어이라키에서 어셋으로 옮긴 후, 프리팝(Prefabs) 디렉토리를 만들고 그때 그때 복제하여 사용하자!

    5. 키 입력 스크립트
        - Unity 프로그램은 Update() 메소드를 통해 실시간으로 변하는 정보를 주기적으로 체크한다. 따라서 이 메소드를 수정하여 키를 입력 받고 오브젝트를 실시간으로 제어한다.
        - Input() 메소드를 통해 키 입력을 감지한다. 대략 1초에 60번 정도 키 입력을 감지한다.
        - 큐브를 점프시켰던 Rigidbody.AddForce() 메소드와 Input.GetKey()를 통해 상하좌우 방향키에 따라 힘을 주는 식으로 코드를 짜본다.
        - Input.GetAxis()와 Vector3, Rigidbody.velocity를 통해 움직임을 개선한다.
            > **AddForce()와 velocity의 차이?**
                - Addforce()는 서서히 속도를 증감시켜 관성의 영향을 받고, velocity에 새로운 속도를 덮어씌우는 것이라 관성을 무시한다.
        - Edit > Project Settings... > Input > Axes에서 Axes 리스트를 훑어본다. 멀티 플랫폼 또한 지원함을 확인한다. (멘토님의 xbox cotroller의 얘기가 바로 이 부분...)
        - 입력을 boolean형이 아닌 숫자로 받는 이유는, 멀티플랫폼에 대응하기 위해서다. 아날로그 스틱의 경우, 스틱을 절반만 밀 경우에 서서히 움직이는 기능을 사용할 수 있다.
        - R을 눌렀을 시 Sample Scene을 LoadScene() 메소드로 불러오는 방법을 배웠다.
        - 게임 종료에 관련한 언급이 없어서 별도로 찾아서 추가했다. ESC를 눌렀을 시에 Application.Quit()으로 종료하는 방법을 배웠다.
    6. UI
        - 스코어링과 최고 스코어 갱신 등 여러가지 글자를 화면에 출력하는 방법을 배웠다.
        - 하이어라키에서 UI > Canvas를 만들고, 내용과 레이아웃을 설정한 다음 GameManger에게 넘겨줘서 출력한다.
        - 게임오버 텍스트 같은 경우 상시 출력이 아니기 때문에, 인스펙터 창의 가장 상단의 가시 여부 체크를 해제했다.


# 간략한 Week03 회고

여러 가지의 버그와 애로 사항을 실제로 겪어볼 수 있는 과제였다. <br/>

1. 이것 저것 실험해 본다고 Collider의 Is Trigger를 체크해놓고 깜빡해서 벽을 통과하는 현상... 🥲 <br/>
2. 벽과 플레이어에 Rigidbody 컴포넌트와 gravity를 추가하니 생기는 웃긴 장면들... 정말 필요하지 않다면 Rigidbody를 굳이 추가하지 말자는 것을 배웠다. 짧은 생각으로는 Rigidbody가 있어야 오브젝트가 서로 통과하지 않으리라고 생각했지만, 그 역할을 Collider가 하고 있었다.
3. 스크립트 파일 이름과 스크립트의 클래스 이름이 일치하지 않을 시에 생기는 컴파일 에러도 겪어봤다.
4. 아무튼 너무 재밌다! 빨리 다음 과제를 하고 싶다! 😊

- p.s. 
* 여태껏 MacBook에서 intel 버전의 Unity와 Rider를 써와서 엄청난 렉에 시달려야 했다. 역시 집단 지성의 위대함... 이 문제 해결에 도움을 준 스터디원분들께 감사를...!
