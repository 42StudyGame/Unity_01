# Week03

# 게임 파일
https://drive.google.com/file/d/17WnD9F1kLPoDXK3d5LYXLaPlxN2FBCZj/view?usp=sharing

# 플레이 영상
https://youtu.be/iIL87222swM

# To Do

- 3주차: 3부 닷지 플레이어 제작 (220p - 359p)
    - 6장 닷지: 플레이어 제작
    - 7장 닷지: 탄알 제작
    - 8장: 닷지: 게임 매니저와 UI, 최종 완성
    - 과제
        - 3부 닷지 게임의 제작 예제 프로젝트를 github에 올리고 플레이 영상도 올려보기
        - 만약 xbox controller나 다른 컨트롤러가 있는 분은 연결해서 해보세요 재밌습니다!


# 6장 | 닷지 (플레이어 제작)

본격적인 게임 개발! 예제 프로그램을 다운 받아 구동해 봤다. <br/>
탄막을 피해 원통을 움직여서 오래 살아남는 게임이다. <br/>
simple is best, 간단하지만 재미난 구성이다. <br/>

* **6장에서 해본 것**
    1. Inspector의 Transform으로 컴포넌트의 스케일과 위치를 수정하기
        - Plane의 크기와 유닛 단위
            유니티에서 1 유닛은 Cube 한 변의 길이다. 1 유닛을 현실의 몇 미터에 대응할지는 개발자 마음이지만, 편의상 1유닛을 1미터로 취급한다.<br/>
    2. 머티리얼(Material)
        - 머티리얼은 Shader와 Texture가 합쳐진 에셋으로, 오브젝트의 픽셀 컬러를 결정한다.
        - 알베도(Albedo)는 반사율이라는 뜻으로, 물체가 어떤 색을 반사할지 결정합니다. 알베도의 RGB 값을 수정해서 물체의 기본색을 결정한다.
    3. 여러 가지 오브젝트 만들고, 카메라 설정하기
        - 바닥과 벽, 그리고 원통 모양의 플레이어를 만들고, 머티리얼을 입혀 색깔을 지정한다.
        - 빈 오브젝트를 만들고 여러 오브젝트를 담을 부모 프로젝트로 지정한하여 복잡해진 하이어라키창을 정리한다.
        - 카메라 위치를 설정하고 디폴트 설정인 스카이 박스(Skybox)를 단색(Solid Color)으로 바꾼다.
        - 캡슐 오브젝트를 만들어 플레이어로 지정하고 푸른색의 머티리얼을 입힌다.
    4. 오브젝트 설정하기
        - 이후에 탄알과 플레이어가 충돌했는지 확인하기 위해 플레이어 오브젝트에 태그(Tag)를 자기 자신으로 추가한다.
            > 이렇게 태그를 설정하면 나중에 탄알이 플레이어와 충돌했을 때만 게임오버를 실행할 수 있다. 
        - 플레이어에 Rigidbody 컴포넌트를 추가하여 물리적인 효과를 준다.
            > Rigidbody의 제약(Constraints)을 추가로 설정한다. y축 Position을 고정하지 않으면 벽을 뛰어 넘어서고, x, z축 Rotation을 고정하지 않으면 오뚝이처럼 뒤뚱거린다. (play 버튼을 누른 후 체크를 해제하면 바로 확인이 가능하다)
        - 키 입력을 받아 움직이는 c# 스크립트를 작성하고, 플레이어 오브젝트의 컴포넌트에 추가한다.
    5. 키 입력 스크립트
        - Unity 프로그램은 Update() 메소드를 통해 실시간으로 변하는 정보를 주기적으로 체크한다. 따라서 이 메소드를 수정하여 키를 입력 받고 오브젝트를 실시간으로 제어한다.
        - Input() 메소드를 통해 키 입력을 감지한다. 대략 1초에 60번 정도 키 입력을 감지한다.
        - 큐브를 점프시켰던 Rigidbody.AddForce() 메소드와 Input.GetKey()를 통해 상하좌우 방향키에 따라 힘을 주는 식으로 코드를 짜본다.
        - Input.GetAxis()와 Vector3, Rigidbody.velocity를 통해 움직임을 개선한다.
            > **AddForce()와 velocity의 차이?**
                - Addforce()는 서서히 속도를 증감시켜 관성의 영향을 받고, velocity에 새로운 속도를 덮어씌우는 것이라 관성을 무시한다.
        - Edit > Project Settings... > Input > Axes에서 Axes 리스트를 훑어본다. 멀티 플랫폼 또한 지원함을 확인한다. (멘토님의 xbox cotroller의 얘기가 바로 이 부분...)
        - 입력을 boolean형이 아닌 숫자로 받는 이유는, 멀티플랫폼에 대응하기 위해서다. 아날로그 스틱의 경우, 스틱을 절반만 밀 경우에 서서히 움직이는 기능을 사용할 수 있다.

# 7장 | 닷지 (탄알 제작)

본격적인 클래스와 객체 지향 프로그래밍에 대해 설명하는 장이다.<br/>
* 프로젝트를 시작하기 전의 반성<br/>
얼마 전, cpp module 평가를 갔을 때 코드 리뷰 중에 피평가자에게 '객체 지향 프로그래밍이 뭐고, 필요성이 뭔가? 절차지향으로도 할 수 있지 않나?'라는 질문을 역으로 받은 적이 있다. 그때 머리로 망치를 맞은 충격을 느낀 적이 있다. 나는 대체 뭘 배운 것일까? <br/>
그렇게 나를 돌아봤다. 절차지향 프로그래밍으로 프로그래밍을 프로그래밍을 처음 배웠고, unity를 하기 위해 객체 지향 프로그래밍을 배우긴 했던 나이기에, 객체 지향 프로그래밍에 대한 필요성을 느꼈기 보다는, '그냥 C#이 객체 지향 프로그래밍이라서 배웠기 때문에' 아직 진정성 있게 절차지향 프로그래밍의 필요성과 결핍성이 없었다. 그로 인해 '절차지향 프로그래밍'과 '객체 지향 프로그래밍'을 이해하고 '구분 짓기'가 필요했다. <br/>

# 객체 지향 패러다임 <br/>
패러다임의 발전 과정을 보면 점점 개발자들이 편하게 개발할 수 있도록 개선되는 방식으로 나아가고 있는 걸 확인할 수 있다.<br/>
가장 먼저 순차적, 비구조적 프로그래밍이 있다. 말 그대로 순차적으로 코딩해나가는 것이다. <br/>
필요한 게 있으면 계속 순서대로 추가해가며 구현하는 방식이다. 직관적일 것처럼 생각되지만, 점점 규모가 커지게 되면 어떻게 될까? <br/>
이런 비구조적 프로그래밍에서는 goto문을 활용한다. 만약 이전에 작성했던 코드가 다시 필요하면 그곳으로 이동한다. 점점 규모가 커지면서 goto문을 무분별하게 사용하게 되고, 코드의 흐름은 이리 뛰고 저리 뛰고 방아깨비 널뛰기 하듯이 난잡해진다. <br/>
<br/>
최단거리를 구하는 '다익스트라 알고리즘'으로 우리에게 익숙한 에츠허르 다익스트라는 1968년 <GOTO문의 해로움>이라는 논문에서 이를 지적하고, '구조적 프로그래밍'을 제안했다.<br/>
<br/>

* **goto문의 대표적인 단점 세가지**
    1. 무조건 분기를 지시하는 저급의 제어 구조이므로 do while문 이나 case문 등과 같은 블록의 개념을 갖지 못한다. <br/>
    2. 프로그램의 흐름을 복잡하게 만들어, 작성된 프로그램의 제어 구조를 이해하기가 어렵다. <br/>
    3. 프로그램의 구조를 불분명하게 만든다. <br/>
    4. 실행의 흐름을 파악하는 것이 코드 읽는 순서랑 다르기 때문에 검증, 수정이 어렵다. <br/>
<br/>

# 구조적 프로그래밍 <br/>

1. 프로그램의 흐름이 복잡하지 않아야 한다.<br/>
2. 큰 문제(프로그램의 목표)를 해결하기 위해 함수를 세분화하여 분업한다. 탑 다운(Top-down)방식이라고 한다.<br/>
3. 단일 입·출구(single entry, single exit)를 가져야 한다.<br/>
4. 가능한 goto문을 사용하지 말자.<br/>
5. 순차, 선택, 반복 논리의 세가지 논리 구조로 구성한다.<br/>
- 순차구조(sequence) : 하나의 일이 수행된 후, 다음 일이 순서적으로 수행된다. (구문 순서에 따라)<br/>
- 선택구조(selction) : 프로그램의 상태에 따라서 여러 구문들 중에서 하나를 수행하는 것이다. 주로 if, then, else, endif, switch, case와 같은 키워드로 표현한다.<br/>
- 반복(repetition) : 프로그램이 특정 상태에 도달할 때까지 구문을 반복하여 수행하거나, 집합체의 각각의 원소들에 대해 어떤 구문을 반복 수행하는 것이다. 보통 while, repeat, for, do-until 같은 키워드로 표현한다.<br/>
6. 반복될 가능성이 있으면, 함수(프로시저)로 만들어 사용해라.<br/>
    > 프로시저(procedure)?<br/>
    반환값(return value)이 따로 존재하지 않는 함수를 뜻한다. 예를 들면, printf와 같은 함수는 반환값을 얻기 위한 것보단, 화면에 출력하는 용도로 쓰이는 함수지만 목적 자체는 프로시저에 가깝다고 할 수 있다.<br/>
<br/>

# 구조적 프로그래밍의 한계와 객체 지향 프로그래밍의 탄생 <br/>

* 구조적 프로그래밍으로 도서 관리 프로그래밍을 만든다고 가정해보자. 그렇다면 구조가 이렇게 될 것이다. <br/>
    1. 어떤 도서가 <도서 등록> 함수에 들어가서 제목과 저자, 번호, 출판사 등의 정보를 입력받고 등록이 된다. <br/>
    2. 어떤 대출자가 어떤 도서를 대출하려고 하면 먼저 그 대출자가 <회원 등록>을 하는 함수에 들어가야 한다. <br/>
    3. 2의 과정을 대출자가 도서를 대출하려면 <도서 대출>이라는 함수에 도서 대출자와 도서 구조체를 인자로 넣어야 할 것이다. 만약 도서가 이미 대출이 됐다면, <도서 대출> 함수는 이미 대여됐다고 알려야 할 것이다. <br/>
    4. 3의 과정에서 도서 대출을 완료했다면 도서 정보에 대출자를, 혹은 회원 정보에 대출한 도서를 입력한다.<br/>
        > 여기서 구조적 프로그래밍의 한계가 등장한다. '도서를 대출했다'는 데이터를 누가 다룰 것이고, 어떻게 다룰 것인가에 대해 모호하다.<br/>
    5. 이하 생략(...)<br/>

# 이를 객체 지향 프로그래밍으로 해결한다면?
* 도서라는 객체<br/>
도서명, 저자, 출판사, 도서번호, (...), 스스로를 회원이라는 객체에 대출하는 함수, 스스로를 반납하는 함수, 대여 여부 등 <br/>
* 대출자라는 객체<br/>
이름, 생년월일, 가입 연도, (...) 대여 정보, 도서 예약하는 함수, 연체했을 시에 대여를 금지하는 함수 등 <br/>

위의 구조적 프로그래밍의 순차적인 구조를 보는 것보다 객체를 들여다 보는 것만으로 코드의 흐름을 한 눈에 파악할 수 있다. <br/>
<br/>

# 객체 지향 프로그래밍의 특징

1. **추상화(abstraction)**<br/>
<br/>
<img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/376197d7-95f3-4c0b-878b-b9d4710bcab6/GAhMIfG.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220726%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220726T044128Z&X-Amz-Expires=86400&X-Amz-Signature=3e865dca898bf0fa3cf74a7f9634bbdde595798ae7e40a8945ca32abdddd29a4&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22GAhMIfG.png%22&x-id=GetObject"><br/>

> 추상화 : 필요로 하는 속성이나 행동을 추출하는 작업. <br/>

* 여기서 추상화된 정보는 클래스이고, 이 클래스가 특별해 지는 순간, 즉 메모리에 올라가는 순간 실체(instance)라고 한다.위로 예를 들면 도서는 클래스이고, <레트로의 유니티 게임 프로그래밍 에센스>는 인스턴스이다. <br/>
* 객체지향 프로그래밍에서 코드 재사용에 가장 가까운 개념일 것이다.<br/>
* 김춘수의 <꽃>이 생각나는 부분이다. 어떤 특별한 이름을 부여받기 전에는 하나의 클래스에 밖에 지나지 않았고, 이름을 불러주자(namespace) 그제야 인스턴스가 됐다. <br/>
<br/>

2. **캡슐화(encapsulation)** <br/>

    > 낮은 결합도를 유지할 수 있도록 설계하는 것. 한 곳에서 데이터에 변화가 일어나도 다른 곳에 미치는 영향을 최소화하는 것을 말한다. 
- 절차 지향 프로그래밍, 그리고 구조적 프로그래밍의 가지는 문제점이 바로 어떤 함수에 잘못된 데이터가 들어가서 데이터가 오염되는 것이다.
- 이를 위해 코드의 결합도(coupling)를 낮게 만들고, 캡슐화와 정보 은닉성이 객체 지향 프로그래밍의 주안점이 됐다.
    > 결합도 : 어떤 기능을 실행할 때 다른 클래스나 모듈에 얼마나 의존적인가를 나타내는 말이다. 즉, 독립적으로 만들어진 객체들 간의 의존도가 최대한 낮게 만드는 것이 중요하다. 객체들 간의 의존도가 높아지면 굳이 객체 지향으로 설계하는 의미가 없어진다. <br/>
- 우리는 소프트웨어 공학에서 객체 안의 모듈 간의 요소가 밀접한 관련이 있는 것으로 구성하여 응집도를 높이고 결합도를 줄여야 요구사항 변경에 대처하는 좋은 설계 방법이라고 배운다. 이것이 바로 캡슐화와 크게 연관된 부분이라고 할 수 있다. 그렇다면, 캡슐화는 어떻게 높은 응집도와 낮은 결합도를 갖게 할까?<br/>
- 바로 정보 은닉을 활용한다. 외부에서 접근할 필요가 없는 것들은 private으로 접근하지 못하도록 제한을 두는 것이다. 위의 도서 프로그램으로 예를 들자면 도서가 스스로를 반납하는 함수를 private으로 둠으로, 대출자 클래스가 스스로를 반납하는 함수에 들어가는 경우를 방지할 수 있다.<br/>
- 실제로 public과 static으로 점철된 코드라면 자동완성 기능에서 필요 없는 메소드를 마구잡이로 추천해 줄 것이다.<br/>
<br/>

3. **상속(inheritance)** <br/>

    > 일반화 관계(Generalization)라고도 하며, 여러 개체들이 지닌 공통된 특성을 부각시켜 하나의 개념이나 법칙으로 성립하는 과정.
* 일반화(상속)은 또 다른 캡슐화다. 부모 클래스로부터 상속 받은 자식 클래스는 외부로부터 은닉되기 때문이다. (도서를 상속 받은 클래스는, 대출자로부터 은닉된다.)

* **상속 재사용의 단점** <br/>
    1. 상위 클래스(부모 클래스)의 변경이 어려워진다.
        > 부모 클래스에 의존하는 자식 클래스가 많을 때, 부모 클래스의 변경이 필요하다면 이를 의존하는 자식 클래스들이 영향을 받게 된다.
    2. 불필요한 클래스가 증가할 수 있다.
        > 유사기능 확장시, 필요 이상의 불필요한 클래스를 만들어야 하는 상황이 발생할 수 있다.
    3. 상속이 잘못 사용될 수 있다.
        > 같은 종류가 아닌 다른 클래스의 구현을 재사용하기 위해 상속을 받게 되면, 문제가 발생할 수 있다. 이런 문제는 전 주에서 짚고 넢어갔는데, 컴포넌트 패턴 혹은 컴포지션으로 해결할 수 있다. 상속 받는 클래스가 부모 클래스와 IS-A(is a relationship) 관계가 아닌, HAS-A 관계(has a relationship)일 때 이에 해당한다. 즉 상속이 코드 재사용만을 위해서 사용되는 일은 없어야 한다.


# 간략한 Week02 회고

여러 가지 얄팍하게 알고 있던 것들에 대해서 조금 명확하게 짚고 넘어갔다. <br/>
또한 큐브 오브젝트에 Rigidbody 컴포넌트를 주어 점프를 시켜봤다. 바닥을 깔지 않으니 끝없이 떨어지는 큐브... 🥲 <br/>
다음 장부터 본격적인 게임 제작에 들어갈 듯하다. 파이팅! <br/>
