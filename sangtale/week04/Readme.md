# Week04

# To do
- 4주차: 4부 공간 (360p - 421p)
    - 9장 방향, 크기, 회전
    - 10장 공간과 움직임
    - 과제
        - 4부 공간 실습한 프로젝트를 github에 올리고 동작 영상 올리기

# 영상 링크


# 벡터 수학
- 벡터(Vector)란?
    - 물리학자, 공학자, 게임 개발자에게 벡터는 공간상의 화살표로 사용된다.
        > 예) (10, 5, 0)은 우측으로 10, 위로 5만큼 이동하는 화살표
    - 데이터를 다루는 프로그래머에게 벡터는 나열된 숫자 데이터를 묶는 단위다.
        > 예) (172, 64)는 키 172, 몸무게 64를 나타내는 데이터
    - 수학자에게는 벡터 연산을 만족하고 정해진 개수의 원소를 가지면 무엇이든 벡터다.

* 유니티는 벡터를 나타내는 Vector 클래스를 사용해서 공간에서 좌표를 표현한다. 

```csharp
// 3차원 벡터
new Vector3(x, y, z);
// 2차원 벡터
new Vector2(x, y);
```

- 절대 위치와 상대 위치?
    - **상대 좌표** : 상대적인 좌표
    - **절대 좌표** : 어떤 대상의 절대적인 좌표

- 벡터의 크기
    - 피타고라스 정리를 통하여 벡터의 크기를 알 수 있다.
```csharp
// 3차원 벡터
Math.sqrt((x * x) + (y * y) + (z * z));
// 2차원 벡터
Math.sqrt((x * x) + (y * y));
```
- 스칼라(Scalar)
    - 스칼라 : 크기만 있고 방향이 없는 물리량
    - 벡터의 좌표값 각각에 n의 스칼라를 곱하면 벡터를 늘리거나 줄일 수 있다.
    - 책에서는 이렇게 돼있다.
        > 스칼라 곱은 벡터의 크기를 늘리거나 줄일 수는 있어도 벡터의 방향을 변경할 수 없습니다.
    - 하지만 스칼라가 음수라면...? 🤔 힘의 크기가 반대로 바뀌는 것이지, 방향 자체는 바뀌지 않는 것으로 해석한 것일까?

- 방향 벡터
    - 정규화된 벡터(normalized vector)라고도 부르며, 크기가 1이다.
    - 만약 어떤 벡터의 방향벡터를 구하고 싶으면?
        1. 벡터의 시작점에서 반지름이 1인 원을 그려 방향을 제외한 나머지 부분인 4분의 3을 잘라낸다.
        2. (3, -3)으로 예를 들면 시작 점에서 1만큼 간 부분의 좌표값은 (0.71, -0.71)이다. (0.707...)
        3. 1은 항등원이고, 따라서 (3, -3)은 이렇게 표현할 수 있다. (3, -3) = (0.71, -0.71) * √(3^2 + -3^2)

- 벡터의 덧셈과 뺄셈
    - 벡터 간에는 덧셈과 뺄셈이 가능하다.
    - 뺄셈은 어떤 대상 A, B와(혹은 그 이상)의 절대 좌표 차이와 거리를 알아낼 수 있다.

- 벡터 내적
    - 적은 '쌓는다'는 뜻의 한자이고, 여기서는 '곱한다'는 뜻이다. 벡터의 곱하기는 두 가지 정의가 있는데, 내적은 벡터를 마치 수처럼 곱하는 개념.
    - 벡터의 내적의 결과값은 벡터가 아닌 스칼라.
    <img srg ="https://wikidocs.net/images/page/22384/inner_product.png">
    - 내적의 기호는 가운데 점을 찍는 것(·)이고, 위 이미지의 벡터 크기를 절대값으로 표시하면, 내적의 값은 다음과 같다.
    - A·B = |A||B|cosθ
    - 내적을 통하여 두 물체 사이의 각도가 얼마만큼 벌어졌는지 쉽게 파악할 수 있다.
        |각도|내적 결과|
        |:---:|:---:|
        |0|+1|
        |0 ~ 90|+1 ~ 0|
        |90|0|
        |90 ~ 180|0 ~ -1|
        |180|-1|

- 벡터 외적
    - 두 벡터를 모두 수직으로 통과하는 벡터를 구하는 연산
    - 외적을 이용해 어떤 표면(평면)에 수직인 방향을 알 수 있다. 평면의 방향을 나타내는 벡터를 노말벡터라고 부른다.


# 유니티 C# 벡터
    - Vector 타입은 유니티 라이브러이 내부에 클래스아 아닌 구조체로 선언되어 있다.
    - 구조체를 선언하는 방법은 클래스와 비슷하다. 다만, 클래스와 달리 참조 타입이 아닌 값 타입으로 동작한다.
    - 따라서 C# 빌트인 변수처럼 변수가 값 자체로 동작한다.

- Vector3 연산
    - Vector3의 기본 연산은 모든 유니티의 C# 라이브러리에 정의되어 있다.
    1. 스칼라 곱
    ```csharp
    Vector3 a = new Vector3(3, 6, 9);
    a = a * 10; // a는 (30, 60, 90)이 된다.
    ```
    2. 벡터의 덧셈 뺄셈
    ```csharp
    Vector3 a = new Vector3(2, 4, 8);
    Vector3 b = new Vector3(3, 6, 9);

    Vector3 c = a + b; // (5, 10, 17);
    c = a - b; // (-1, -2, -1); 
    ```
    3. 벡터의 정규화(방향벡터 만들기)
    - Vector3.normalized
    ```csharp
    Vector3 a = new Vector3(3, 3, 3);
    Vector3 b = a.normalized;
    ```
    4. 벡터의 크기(길이)
    - Vector3.magntude
    5. 벡터의 내적
    - Vector3.Dot(a,b);
    6. 벡터의 외적
    - Vector3.Cross(a,b);
    7. 벡터 사이의 거리
    - Vector3.Distance(currentPos, destPos);

- 쿼터니언(quaternion)
    - 쿼터니언은 회전을 나타내는 타입이다.
    - 인스펙터 창에서 트랜스폼 컴포넌트는 x, y, z를 가지는 Vector3로서 위치, 회전, 스케일을 나타낸다.
    - rotation은 인스펙터 창에서 x, y, z 값을 받지만, Vector3 타입이 아닌 쿼터니언 타입이다. 유니티가 직관성을 위해 Vector3로 다루도록 배려한 것이다.

- 짐벌락(gimbal lock)
    - 오일러각?
        - 3D 벡터를 사용해 3D 회전을 나타내는 표현
        - 물체가 '회전하기 전의 좌표계'에서 '회전한 다음의 좌표계'로 바뀌려면 기존 좌표계를 세 번에 걸쳐 얼마만큼 회전하면 되는지, 세 각도로 물체의 회전을 표현
        - 풀어 쓰면 회전하기 전 상태에서 회전한 다음 상태까지의 3단계
    - 짐벌락이란?
        <img src="https://blog.kakaocdn.net/dn/xr8Hv/btrmZ1QlbAD/rqXfRzKwF2xGnkXHii2gok/img.gif">
        - 크기가 각각 다른 세 고리가 회전하는 모형인 짐벌이 있고, 안쪽 고리가 회전축을 소실하는 현상
        - 각각의 고리는 고유한 축을 기준으로 회전하는데 이는 가장 바깥쪽 고리만 해당할 뿐 안쪽 고리들은 여러 방향으로 회전함을 알 수 있다.
        - 안쪽 고리가 여러 방향으로 회전하는 이유는 고리가 종속 관계를 형성하기 때문이다. 즉 한 고리의 회전이 안쪽 고리의 회전에 영향을 주며 고리의 회전으로 인해 의도치 않게 두 개 이상의 고리가 겹치게 되면 한 축의 회전각이 소실되는데 이 현상을 짐벌락이라 한다.
        <img src="https://blog.kakaocdn.net/dn/dZtKME/btrm0qijxg2/OwYyeoqI7ZMobFvUvXEK90/img.gif">
        - 녹색 고리의 회전으로 인해 분홍색 고리와 파란색 고리가 겹치게 되면 두 고리의 회전은 동일한 결과를 낳게 되면서 자연스럽게 한 축의 회전은 소실된다.
        - 어떤 축(x, y, z)의 회전이 다른 축의 회전에 영향을 주고, 이에 따라 오일러각 체계에서는 두 번의 회전에 의해 세 번째 회전이 자유도를 상실한다.

- 다시 쿼터니언
    - 유니티는 인스펙터 뷰에 강체의 방향을 보다 직관적으로 조작할 수 있도록 오일러 각으로 표현하고 있다.
    - 하지만 내부적으로 쿼터니언 방식으로 강체의 방향을 표현하니 개발자가 의도적으로 오일러 각을 사용하도록 유도하지 않으면 유니티에서 짐벌락 현상은 발생하지 않는다.  
    - 쿼터니언은 복소수를 확장한 x, y, z, w 성분을 갖는 4차원 벡터로 세 개의 축을 동시에 회전시켜 축에 대한 종속 관계를 없앴으며 하나의 축이 소실되는 문제점을 방지할 수 있다.

    - 쿼터니언의 장점 
        1. 짐벌락 문제가 발생하지 않는다.
        2. 계산 비용이 적다.
    - 쿼터니언의 한계점
        1. 직관적이지 않다. 원리를 이해하지 못하면 쿼터니언을 사용할 수 없다. 다행히도 유니티에선 Vector3를 넘겨주면 쿼터니언으로 바꿔주는 메서드가 존재한다.
        2. 회전을 하나의 방향에서 다른 방향으로 측정하기 때문에 180도 보다 큰 회전을 표현할 수 없다.
    - 쿼터니언 메소드
        - Quaternion.Euler()
        - 회전을 Vector3(오일러각)로 가져오기
            - Quaternion 타입은 저장된 회전값을 Vector3 타입의 오일러각으로 변환된 변수 eulerAngles를 제공한다.
        ```csharp
        Quaternion rotation = Quaternoin.Euler(new Vector3(0, 60, 0));
        // Vector3 타입의 값으로 (0, 60, 0)이 나온다.
        Vector3 eulerRotation = rotation.eulerAngles;
        ```
    - 현재 회전에서 더 회전하기
        ```csharp
        Quaternion a = Quaternoin.Euler(30, 0, 0);
        Quaternion b = Quaternoin.Euler(0, 60, 0);

        // a만큼 회전한 상태에서 b만큼 더 회전한 값을 표현
        Quaternion rotation = a * b;
        // 여기서 더 회전은 덧셈이 아니라 곱셉으로 표현한다.
        ```
