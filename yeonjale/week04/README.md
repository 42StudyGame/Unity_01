# 4주차: 4부 공간 (360p - 421p)
	9장 방향, 크기, 회전
	10장 공간과 움직임
	과제
	    1. 4부 공간 실습한 프로젝트를 github에 올리고 동작 영상 올리기


## 9장 방향, 크기, 회전
### 벡터 수학

벡터 값만으로 방향과 속력을 직관적으로 파악할 수 있다.

벡터 값은 (다른 벡터 값) x (스칼라)으로 표현할 수 있고, 이는 다시 (방향) x (속력)으로 표현 가능하다. 예를 들어, 벡터 (3, -3)은 (1, -1) x 3으로 방향은 (1, -1), 속력은 3으로 표현 가능하다.

하지만, 벡터 (3, -3)의 실제 크기(속력)은 3이 아니다. 벡터 (1, -1)의 크기는 1.414…로 벡터 (3, -3)의 실제 크기는 1.414… x 3인 4.242…이다. 즉, 스칼라 곱을 하기 전 벡터의 크기가 1이 아닌 경우 실제 크기를 알 수 없다.

**방향벡터 (정규화된 벡터(Normalized Vector))**

방향벡터는 크기가 1인 벡터로 크기가 서로 다른 벡터를 비교하는 기준이 된다.

만악 벡터 (1, -1)의 방향벡터를 구하고 싶다면 벡터의 시작점에서 반지름이 1인 원을 그려서 (1, -1)의 원 바깥 부분을 잘라내면 된다. 이처럼 기존 벡터를 방향벡터로 만드는 것을 “벡터 정규화”라고 부른다.

벡터 (1, -1)을 정귷화 하면 대략 (0.71, -0.71)이며 이는 벡터 (3, -3)을 정규화한 값이다. 즉, 벡터 (3, -3)은 (0.71, -0.71) x 4.24로 방향은 (0.71, -0.71), 속력은 4.24가 된다.

벡터 정규화:

```csharp
Vector3 a = new Vector3(3, 3, 3);
Vector3 b = a.normalized; // b : (0.6, 0.6, 0,6)

float mag = b.magnitude;  // mag : 대략 5.19...
```
**뺄셈의 이해 (수평선)**

뺄셈을 정확히 이해할 필요가 있는데, 수평선상에서 보면 이해해가 쉽다.

A = 3, B = 10이라 가정하면

B - A은 7이다. 7의 의미는 A에서 B까지의 간격이며 A에서 B로 가려면 + 방향(오른쪽)으로 7만큼 가야 한다는 의미이다. 즉, A에서 B까지의 방향과 거리를 나타낸다고 해석할 수 있다.
A - B는 -7이다. -7의 의미는 B에서 A까지의 간격이며 B에서 A로 가려면 - 방향(왼쪽)으로 7만큼 가야 한다는 의미이다. 즉, B에서 A까지의 방향과 거리를 나타낸다고 해석할 수 있다.

이 법칙은 수평선뿐만 아니라 2, 3차원 좌표계에도 공통적으로 적용된다.

**뺄셈의 이해 (공간)**

공간에서도 마찬가지로 B - A는 A에서 B까지의 뱡향과 거리를 나타낸다.

이 법칙을 게임상에서 표현하면, 몬스터가 플레이어를 잡기 위해 이동해야 할 방향과 거리는 (플레이어 위치) - (몬스터 위치) 즉, 몬스터에서 플레이어까지의 방향과 거리로 나타낼 수 있다.

벡터 덧셈, 뺄셈 연산:

```csharp
Vector3 a = new Vector3(2, 4, 8);
Vector3 b = new Vector3(3, 6, 9);

Vector3 c = a + b; // c : (5, 10, 17)
Vector3 d = a - b; // d : (-1, -2, -1);

Vector3 delta = b - a; // a에서 b로 향하는 벡터

// a에서 b까지의 방향과 거리
Vector3 direction = (b - a).normalized; // 방향벡터
float distance = delta.magnitude; // 거리

// a에서 b까지의 거리를 구하는 다른 메서드
float distance = Vector3.Distance(a, b);
```
**벡터의 내적**

벡터의 내적은 “점 연산(Dot Product)”라 부르기도 하며, 벡터 A와 B사이의 각도를 구하기 위해 사용한다.

연산은 벡터 B를 벡터 A에 투영하여, 그 투영하여 얻은 벡터에 벡터 A의 크기를 곱한다.

|B|cos𝜽 x |A| = A · B

*투영하여 얻은 벡터란 쉽게 설명하면 ‘그림자’라고 생각하면 된다. 바닥에 막대기를 세워 만든 해시계를 떠올리면 막대기와 바닥 사이의 각도에 따라 그림자의 길이가 바뀌는데 막대기를 벡터 B, 바닥을 벡터 A, 그림자를 벡터 B를 A에 투영하여 얻은 벡터로 생각하면 된다.

두 방향벡터 사이의 각도에 다른 내적 결과는 다음과 같다.

(둘 사이의 각도) : (내적 결과)\
0 : +1\
0 ~ 90 : +1 ~ 0\
90 : 0\
90 ~ 180 : 0 ~ -1\
180 : -1

벡터의 내적은 탱크의 포선이 얼마만큼 벌어졌는지, 플레이어의 시선 방향과 플레이어가 실제로 이동하는 방향 사이의 각도가 얼마나 벌어졌는지 등을 쉽게 파악하는데 사용된다.

벡터의 내적:

```csharp
Vector3 a = new Vector3(0, 1, 0);
Vector3 b = new Vector3(1, 0, 0);

float c = Vector3.Dot(a, b); // 수직인 벡터끼리 내적하면 결과는 0
```
**벡터의 외적**

벡터의 외적은 “Cross Product 또는 Vector Product”라 부르기도 하며, 어떤 평면에 표함되는 두 벡터를 수직으로 통과하는 벡터를 구하년 연산이다.

주의할 점은, 어떤 평면 L에 속하는 두 벡터 A와 B의 외적 C(A X B = C)가 있을 때 B X A는 C가 아닌 -C이다. 즉, 외적의 연산 순서를 뒤집으면 외적의 방향은 반대가 된다.

	Notes.
	
	내적의 결과는 숫자, 외적의 결과는 벡터이다.

위에서 말했듯이 평면 L에 포함되는 두 벡터 A와 B의 수직 벡터가 외적이면 다른말로 C는 L이 바라보는 ‘방향’으로 볼 수 있다.

즉, 벡터 C를 정규화하면 평면 L의 방향으로 사용할 수 있다.

이러한 벡터 C를 “Normal Vector 또는 법선벡터”라 부른다.

벡터의 외적:

```csharp
Vector3 a = new Vector3(0, 0, 1); // 앞쪽(Z) 방향벡터
Vector3 b = new Vector3(1, 0, 0); // 오른쪽(X) 방향벡터

Vector3 c = Vector3.Cross(a, b); // c는 a,b와 수족인 위쪽(Y) 방향벡터
```
### 유니티 Vector 타입

Vector 타입은 유니티 라이브러리에 클래스가 아닌 구조체(struct)로 선언되어 있다.

```csharp
public struct Vector3
{
	public float x;
	public float y;
	public float z;
	...
}
```

(중요) 클래스 타입 변수는 참조 타입인 반면, 구조체 타입 변수는 값 타입이다.

```csharp
Vector3 a = new Vector3(0, 0, 0);
Vector3 b = a;
b.x = 100;
```

 위 코드에서 Vector3가 클래스이자 참조 타입이면 a와 b값은 다음과 괕다.

```csharp
a : (100, 0, 0)
b : (100, 0, 0)
```

반면, Vector3가 구조체이자 값 타입이면 a와 b값은 다음과 같다.

```csharp
a : (0, 0, 0)
b : (100, 0, 0)
```
## Quaternion

쿼터니언을 이해하려면 먼저 오일러각(Euler Angle)의 이해가 필요하다.

### 오일러각(Euler Angle)

3D 벡터(Vector3)로 3D 회전을 나타내는 표현으로, 회전 전 상태에서 회전한 다음 상태가 될 때 z-x-y 순으로 세 번에 결쳐 회전하여 세 각도로 물체의 회전을 표현하는 방식이다.

**짐벌락(Gimbal Lock)**

짐벌락은 오일러각에서 흔히 발생하는 문제로 x, y, z축이 z-x-y 순으로 회전하면서 한 축이 다른 축과 겹치면서 한 축이 제 기능을 상실하는 것을 말한다.

오일러각의 한 축을 기준으로 하는 회전은 다른 축에 영향을 주는데, 그 이유는 축들이 계층 구조를 이루고 있기 때문이다. 계층 구조는 총 6가지(zxy, zyx, yxz, yzx, xyz, xzy)가 있다. 계층의 맨 위 축의 회전은 다른 두 축을, 중간 축의 회전은 아래 축에 영향을 주며, 맨 아래 축의 회전은 다른 두 축에 영향을 주지 않는다.

예를 들어, 계층 구조가 zxy(맨 위 축이 y, 중간 축이 x, 맨 아래 축이 z)인 오일러각에서 짐블락이 발생하는 경우는 다움과 같다.
x축을 기준으로 90도 회전하면 맨 아래 축인 z축도 함께 90도 회전하게 된다. (z축을 기준으로 회전하는 것이 아닌 x축을 기준으로 z축이 90도 회전한다.) 이렇게 되면 z축이 y축과 겹치게 되는데, z축을 기준으로 회전하는 것과 y축을 기준으로 회전하는 것 사이에 차이가 없어진다. 즉, z축이 제 기능을 상실하게 된다.

### Quaternion

쿼터니언은 운소로 x, y, z, w를 가지는 값으로, 사원수라고 부르기도 한다.

세 번에 걸쳐 회전하는 오일러각과 달리 쿼터니언은 ‘한 번에 회전하는’ 방식이기 때문에 짐불락을 피할 수 있다. 따라서, 게임에서 회전을 구현할 때는 쿼터니언을 사용한다.

하지만, Unity에서 Transform 컴포넌트를 보면 Rotation을 쿼터니언이 아닌 Vector3 타입인 오일러각을 사용한다. 그 이유는, 쿼터니언은 복잡한 계산법을 기반으로 하기 때문에 내부에서는 쿼터니언을 사용하지만 인스펙터 창에서는 쉽게 사용할 수 있도록 오일러각으로 변형하여 표현한다.

Quaternion을 사용한 예제:

```csharp
// Vectir3 타입인 오일러각을 사용하여 Quaternion 값을 생성
Quaternion rotation = Quaternion.Euler(new Vector3(0, 60, 0));

// Vector3 타입의 오일러 값으로 변형
Vector3 eulerRotation = rotation.eulerAngles;
```

```csharp
Quaternion a = Quaternion.Euler(30, 0, 0);
Quaternion b = Quaternion.Euler(0, 60, 0);

// a만큼 회전한 상태에서 b만큼 더 회전한 회전값
Quaternion rotation = a * b;
```

(중요) a 상태에서 b만틈 더 회전한 회전값은 a + b가 아닌 a * b이다.

##  10장 공간과 움직임
### **Local and Global Space**

전역 공간(Global 또는 World Space)은 게임 월드의 X, Y, Z 방향을 오브젝트의 좌표 기준으로 사용한다.

오브젝트 공간(Object Space)는 오브젝트 자신의 X, Y, Z 방향을 자신의 좌표 기준으로 사용한다.

지역 공간(Local Space)는 부모 게임 오브젝트의 X, Y, Z 방향을 자식 게임 오브젝트의 좌표 기준으로 사용한다.

Local Space이면 Object Space가 활성화 되는데, 사실상 Local Space는 Object Space이며 부모-자식 관계를 나타내는 Local Space는 Global/Object Space에 공종한다고 볼 수 있다.
Global Space에서도 Local Space(부모-자식 관계)는 존재한다. Global Space에서 부모-자식 관계의 부모 게임 오브젝트를 움직이면 자식 게임 오브젝트의 좌표는 부모를 기준으로 한다. 이는 Object Space에서도 마찬가지이다. 하지만, 달라지는 점은 자식 게임 오브젝트의 방향이다. Global Space에서는 게임 월드의 방향을 기준으로 하며, Local Space(Object Space)에서는 자신의 방향을 기준으로 한다.

**Pivot/Center**

Pivot은 오브젝트의 기준점이 오브젝트의 실제 기준점이며, Center는 ‘눈으로 보이는 오브젝트의 중점’이다.

일반적으로 사람 형태의 3D 모델은 발바닥 근처를 기준점으로 하며, Pivot 모드로 씬 창에서 보면 사람 모델의 발바닥 근처에 기준점이 있다. Center 모드로 보면 실제 기준점을 무시하고 사람 모델의 가슴 근처에 기준점이 있다.
