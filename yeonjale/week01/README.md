# 1주차: 1부 유니티 준비하기 (32p - 123p)
    ## 1장 유니티 준비하기
    ## 2장 유니티 인터페이스 둘러보기
    ## 3장 유니티 엔진이 동작하는 원리
    ## 과제
        1. 2장 중심으로 실제 유니티를 설치하고 사용하면서 영상을 제작해서 올려보기
        2. 3장에서 논의하고 싶은 부분 1개 이상 작성하고 서로 얘기하고 이해하는 시간


# 요약 및 정리
- 1장 유니티 준비하기
	
	유니티 장점:
	- 대부분 기능이 개인 개발자에게 무료
	- 현제 가장 많이 사용하는 엔진. 한국어, 영어 자료가 풍부하다.
	- 멀티 플렛폼 빌드 가능

	게임 개발 입문에 유니티를 추천하는 이유:
	- 유니티는 게임 오브젝트를 미리 만들고 그 오브젝트를 제어하기 위해 코드를 작성한다. 즉, 게임을 개발할 때 바닥부터 코딩을 할 필요가 없어서 뛰어난 프로그래머가 아니어도 쉽게 개발할 수 있다.

	### 유니티 구성
	- Hierarchy\
		현재 씬(Scene)에있는 게임 오브젝트를 표시한다.
	- Inspector\
		게임 오브젝트의 정보와 컴포넌트를 보여준다

	### 컴포넌트 종류
	- 트랜스폼 (Transform)\
		오브젝트의 3차원 좌표와 크기, 회전을 지정합니다.
	- 메시 필터 (Mesh Filter)\
    	3D 메시 파일을 받아 오브젝트의 외곽선을 지정합니다.
	- 메시 렌더러 (Mesh Renderer)\
    	메시를 따라 색을 채워 그래픽 외형을 그립니다.
	- 박스 콜라이더 (Box Collider)\
    	다른 물체가 부딪칠 수 있는 물리적인 표면을 만듭니다.
	- Rigidbody\
    	게임 오브젝트가 물리와 중력의 영향을 받게 함.

- 2장 유니티 인터페이스 둘러보기

	씬 편집 툴:

	**핸드 (Hand) 툴** : 씬 카메라를 움직입니다.\
	**평행이동 (Translate) 툴** : 오브젝트를 이동시킵니다.\
	**회전 (Rotate) 툴** : 오브젝트를 회전시킵니다.\
	**스케일 (Scale) 툴** : 오브젝트의 크기를 조정합니다.\
	**렉트 (Rect) 툴** : UI와 2D 오브젝트의 크기를 조정합니다.\
	**트랜스폼 (Transform) 툴** : 평행이동, 회전, 스케일 툴을 하나로 합친 툴입니다.

	- 커스텀 툴\
		개발자가 원하는 기능을 직접 구현하여 할당할 수 있는 버튼. 현재 선택한 오브넥트에 따라 다른 버튼을 지정할 수 있다.


	핸드 툴로 씬 카메라 이동:
	- Flythrough 모드\
		오른쪽 마우스를 누르는 동안 FPS 게임을 하듯 움직일 수 있다.
	- 궤도(Orbit) 모드\
    	(Windows: Alt+left-mouse, Mac: cmd+left-mouse)\
		씬 중심을 기준으로 회전.\
		궤도모드에서 right-mouse를 사용하면 zoom-in/zoom-out 할 수 있다.


	평행이동 툴:
	- 평행이동 툴의 면을 드래그\
		한 축을 고정시키고 다른 두 축을 움직임.

	**빨간색** : X축(오른쪽)\
	**초록색** : Y축(위쪽)\
	**파란색** : Z축(앞쪽)

	회전 툴:

	**빨간색** : X축(앞뒤로 고개를 숙이고 젖히는 회전)\
	**초록색** : Y축(제자리에서 팽이처럼 도는 회전)\
	**파란색** : Z축(오뚝이처럼 좌우로 기울어지는 회전)

	랙트 툴:\
		주로 UI와 2D 오브텍느를 편집할 때 사용.3D 오브젝트를 편집할 때는 거의 사용하지 않음. 랙트 툴로 3D 오브젝트를 편집하면 Z축 방향을 무시하고 가로(X), 세로(Y) 길이만 조정됨.

	- Gizmo란 씬 창에서 오브젝트 위에 표시되는 아이콘, 편집 툴의 모습(화살표), 외곽선 등을 가리킨다. 씬 창에서 보이는 카메라 아이콘도 카메라의 기즈모다

- 3장 유니티 엔진이 동작하는 원리

	’상속'이란 동일한 기능을 가질 클래스들을 공통 기능을 매번 구현하지 않고 만둘기 위한 방법이다.

	이때, 공통 기능 클래스를 ‘부모 클래스' 부모 클래스를 상속 받은 클래스를 ‘자식 클래스’라 부른다.

	사용시 장점:
	- 미리 만들어진 코드를 확장하여 새로운 코드를 작성할 수 있다.

	사용시 단점:
	- 재사용이 힘들 수 있다. (공통 기능이 없는/일부 다른 클래스가 있을 경우)
	- 독립성이 떨어진다.\
		부모 클래스의 각 기능이 서로 의존할 때 일부 기능을 수정하면 다른 기능에 문제가 발생할 수 있다.
	- 기획자의 흐로그래머 의존도가 높아진다.

	‘컴포넌트 패턴’이란 하나의 기능을 가지는 컴포넌트를 만들어 컴포넌트로 새로운 게임 오브젝트를 구성하여 만드는 방법이다.

	사용시 장점:
	- 재사용이 가능하다.\
		컴포넌트는 (상속의 부모 클래스처럼 여러 기능을 가지지 않고) 하나의 기능만을 가지고 있어, 수정할 필요 없이 게임 오브젝트에 추가/삭제 가능하다.
	- 독립성이 높다.\
		각 컴포넌트는 서로 의존하기 않기 때문에 한 컴포넌트의 기능을 수정해도 다른 컴포넌트 기능에 문제가 앖다.\
		게임 오브젝트는 단순한 빈 껌데기에 불과하기 때문에 구성하는 컴포넌트를 일부 삭제해도 게임 오브젝트는 해당 기능만 잃을 뿐 문제가 없다. (상속의 자식 클래스의 기능은 부모 클래스의 기능처럼 서로 의존하기 때문에 일부 삭제되면 클래스에 문제가 발행한다.)
	- 기획자의 프로그래머 의존도가 낮아진다.

	‘Monobehaviour’란 컴포넌트에 필요한 기본 기능을 제공하는 부모 클래스이다. Monobehaviour를 상속한 자식 클래스는 게임 오브젝트에 컴포넌트로서 추가될 수 있고, 유니티의 제어를 받게 된다.

	‘브로드캐스팅’이란 유니티 엔진이 원하는 기능을 실행시키는 방식으로, 말 그대로 존재하는 모든 게임 오브젝트에 기능 실행 메시지를 브로드캐스팅 한다.

	주요 특징:
	- 컴포넌트의 독립성을 유지할 수 있다.\
    	메시지를 보내는 쪽은 누가 받게 될지 신경X\
    	메시지를 받는 쪽은 누가 보냈는지 신경X\
    	메시지를 받았을 때 명시된 기능이 있다면 실행O 아니면 실행X
    
    브로드캐스팅은 오브젝트를 직접 가리키지 않고 ‘당사자를 직접 찾아가는’ 방법 대신 메시지를 보내 원하는 기능을 수행하게 한다.


---
# 과제2
## 3장에서 논의하고 싶은 부분 1개 이상 작성하고 서로 얘기하고 이해하는 시간

Q1. 여러 게임 오브젝트가 서로 의존할 경우, 컴포넌트 패턴의 독립성은 떨어지지 않을까?

	부모 클래스의 기능들은 서로 의존하여 '상속'의 독립성이 떨어지는 반면 '컴포넌트 패턴'은 컴포넌트끼리 의존하지 않아 독립성이 높다고 한다.
	그럼, 어떤 게임 오브젝트의 스크립트에서 다른 게임 오브젝트의 특정 컴포넌트를 사용/참조한다면 특정 컴포넌트를 삭제할 경우 문제가 발생하지 않을까?
